//
// Script that visualizes the post-fit nuisance parameters
//
// Usage :
//  root -b plotPostNuisance_combine.C'("mlfit.root", true)'
//
// Arguments :
//  * char* mlfit : name of the root file returned by combine
//                  This can be generated by the following command
//                  $ combine -M MaxLikelihoodFit --saveNorm [card]
//  * bool skipmu :      flag to decide whether to show mu or not
//

void printaline(int index, char* nuiname, Double_t centralval, Double_t uncert){

  cout.width(5);  cout << index << " ::: ";
  cout.width(40); cout << nuiname << " : ";
  cout.width(10);  cout << Form("%1.3f", centralval);
  cout.width(5);  cout << " +/- ";
  cout.width(10);  cout << Form("%1.3f", uncert) << endl;

}

void plotPostNuisance_combine(TString mlfit="fitDiagnostics_2b_2017_fit_CRonly_result_Scaled_tt_1p2.root", TString outdir="plots_limit/pulls/",
			      TString postfix="ttInWJets_binnedTF",
			      double MaxUncertainty = 1.0,
                              double MaxValue = 10.0, bool skipmu = true) {

  //
  // Read a mlfit.root file and the list of post-fit nuisance parameters
  // from S+B fit (fit_s)
  //
  TFile *File = TFile::Open(mlfit, "READ");
  RooFitResult *fit_s = (RooFitResult*)File->Get("fit_b");
  if(!fit_s)  return;
  //if(fit_s->status() != 3) { cout << " MINUIT status is not 3 "  << endl; continue; }
  RooArgList parlist = fit_s->floatParsFinal();

  //
  // Containers for post-fit nuisances
  //
  std::vector<TString> nuisance;  // nuisance name
  std::vector<Double_t> central;  // post-fit central value  : normalized to the input uncertainty
  std::vector<Double_t> uncert;   // post-fit uncertainty    : normalized to the input uncertainty
  std::vector<TString> nuisance_all;  // nuisance name
  std::vector<Double_t> central_all;  // post-fit central value  : normalized to the input uncertainty
  std::vector<Double_t> uncert_all;   // post-fit uncertainty    : normalized to the input uncertainty

  //
  // Loop over RooArgList and store the fit results
  // in the above containers
  //
  cout << "MaxUncertainty: " << MaxUncertainty << endl;
  cout << "-------------------------------------------------------------------------------" << endl;
  cout << "Index :::               Nuisance name              :       Pull +/- uncertainty" << endl;
  cout << "-------------------------------------------------------------------------------" << endl;
  for(int i=0; i<parlist.getSize(); i++) {

    TString name_tstr = parlist[i].GetName();
    std::cout<<" name_tstr: "<<name_tstr<<std::endl;
    if( skipmu && name_tstr == "r" ) continue;
    //if (name_tstr == "rrvbc_SR_tt_2b4" || name_tstr == "rrvbc_SR_wjets_2b4" || name_tstr == "rrvbc_SR_zjets_2b4") continue ;
    //if (name_tstr.Contains("rrvbc")) continue ;
    if(((RooRealVar&)parlist[i]).getError() < MaxUncertainty)
      //printaline( i+1, parlist[i].GetName(),  // index here is same as plot (i+1), not parlist (i)
      //		  ((RooRealVar&)parlist[i]).getVal(),
      //	  ((RooRealVar&)parlist[i]).getError());

    central_all.push_back( ((RooRealVar&)parlist[i]).getVal() );
    uncert_all.push_back( ((RooRealVar&)parlist[i]).getError() );
    nuisance_all.push_back( parlist[i].GetName() );

    if(((RooRealVar&)parlist[i]).getVal() < 10){

        central.push_back( ((RooRealVar&)parlist[i]).getVal() );
        uncert.push_back( ((RooRealVar&)parlist[i]).getError() );
        nuisance.push_back( parlist[i].GetName() );
        }


  }
  cout << "-------------------------------------------------------------------------------" << endl;

  //
  // Visualize the result
  //
  // * gray area corresponds to post-fit cenral value and pre-fit uncertainty
  // * solid lines correspond to post-fit central value and post-fit uncertainty
  // Purpose of gray area is to compare pre/post-fit uncertainty and
  // check how better data constrains a nuisance than prediction
  TCanvas *c = new TCanvas("c", "c", 1400, 900);
  c->SetBottomMargin(0.35);
  //c->Divide(1,2);
  // c->SetLogy(1);

  // store nuisances with pull >= 1
  // value is set in line 76 : if(TMath::Abs(central[i])>=1)
  int nchangednuisance = 0;
  std::vector<TString> changednuisance;

  c->cd(1);
  int nbins = central.size()+2;
  TH1D* h1        =   new TH1D("h1",      "h1",       nbins, -0.5, nbins-0.5); // post-fit central value and post-fit uncertainty
  TH1D* h1_ref    =   new TH1D("h1_ref",  "h1_ref",   nbins, -0.5, nbins-0.5); // post-fit central value and pre-fit uncertainty

  cout << endl;
  cout << " ****************************** LARGE VARIATION ****************************** " << endl;
  for(int i=0; i<nbins-2; i++) {
    h1->SetBinContent(i+2, central[i]);
    h1->SetBinError(i+2, uncert[i]);
    // h1->SetBinError(i+2, uncert[i]/1000);
    h1_ref->GetXaxis()->SetBinLabel(i+2, nuisance[i]);
    h1_ref->SetBinContent(i+2, central[i]);
    h1_ref->SetBinError(i+2, 1.);
    // h1_ref->SetBinError(i+2, 1./1000);
    if(TMath::Abs(central[i]) >= MaxValue) {
      nchangednuisance++;
      changednuisance.push_back(Form("%2i ::: %s : %1.3f +/- %1.3f", i+1, nuisance[i].Data(), central[i], uncert[i]));
        // printaline( i+1, nuisance[i], central[i], uncert[i]);
    }
  }
  cout << " ****************************************************************************** " << endl;
  cout << endl;
  TPaveText *pt = new TPaveText(0.0877181,0.9,0.9580537,0.96,"brNDC");
  pt->SetBorderSize(0);
  pt->SetTextAlign(12);
  pt->SetFillStyle(0);
  pt->SetTextFont(52);

  double cmstextSize = 0.07;
  double preliminarytextfize = cmstextSize * 0.7;
  double lumitextsize = cmstextSize *0.7;
  pt->SetTextSize(cmstextSize);
  pt->AddText(0.01,0.57,"#font[61]{CMS}");

  TPaveText *pt1 = new TPaveText(0.0877181,0.905,0.9580537,0.96,"brNDC");
  pt1->SetBorderSize(0);
  pt1->SetTextAlign(12);
  pt1->SetFillStyle(0);
  pt1->SetTextFont(52);
  pt1->SetTextSize(preliminarytextfize);
  //pt1->AddText(0.155,0.4,"Preliminary");
  pt1->AddText(0.125,0.4,"Internal");

  TPaveText *pt2 = new TPaveText(0.0877181,0.9,0.8280537,0.96,"brNDC");
  pt2->SetBorderSize(0);
  pt2->SetTextAlign(12);
  pt2->SetFillStyle(0);
  pt2->SetTextFont(42);
  pt2->SetTextSize(lumitextsize);

  string yearstring = std::string(mlfit);
  if (yearstring.find("2017") != std::string::npos) {
    pt2->AddText(0.81, 0.5, "41.5 fb^{-1} (13 TeV)");
  }
  else if (yearstring.find("2016") != std::string::npos){
    pt2->AddText(0.81, 0.5, "35.9 fb^{-1} (13 TeV)");
  }
  else if (yearstring.find("2018") != std::string::npos){
    pt2->AddText(0.81, 0.5, "59.6 fb^{-1} (13 TeV)");
  }
  else if (yearstring.find("run2") != std::string::npos){
    pt2->AddText(0.81, 0.5, "138 fb^{-1} (13 TeV)");
  }

  TPaveText *pt3 = new TPaveText(0.0377181,0.85,0.9580537,0.88,"brNDC");
  pt3->SetBorderSize(0);
  pt3->SetTextAlign(12);
  pt3->SetFillStyle(0);
  pt3->SetTextFont(42);
  pt3->SetTextSize(lumitextsize);
  TString latexText = "Data";
  // if (filename.Contains("data")) latexText = "Data";
  // if (filename.Contains("asimov")) latexText = "Asimov";
  latexText = "CRonly";

  pt3->AddText(0.1,0.4, latexText+" Fit");
  //h1_ref->LabelsDeflate("X");
  h1_ref->LabelsOption("v");

  h1_ref->SetStats(0);
  h1_ref->SetTitle("");
  h1_ref->SetYTitle("Pull");
  h1_ref->SetFillColor(18);
  h1_ref->SetMinimum(-3.0);
  h1_ref->SetMaximum(3.0);
  h1_ref->GetYaxis()->SetNdivisions(3, false);

  //h1_ref->SetFillStyle(3004);
  h1->SetLineColor(kBlack);

  // Draw a horizontal line at 0
  TH1D* h1_zero    =   new TH1D("h1_zero", "h1_zero", 1, -0.5, nbins-0.5);
  h1_zero->SetBinContent(1,0);
  h1_zero->SetLineStyle(2);

  h1_ref->Draw("E2");
  h1_zero->Draw("histo same");
  h1->Draw("same E");
  h1->SetLineColor(2);
  h1->SetLineWidth(2);
  h1->SetMarkerStyle(20);
  h1->SetMarkerSize(1.5);
  pt->Draw();
  pt1->Draw();
  pt2->Draw();
  pt3->Draw();

  //h1_ref->SetAxisRange(1, 45, "X");
  //cout << "nuisance_all"  << nuisance_all.size() << endl;
  int nuisanceRange = 90;
  int numberOfNuisance = nuisance_all.size();
  int numberOfCanvas ;
  numberOfCanvas = (numberOfNuisance/nuisanceRange) +1;
  cout << "nuisance_all"  << nuisance_all.size() << endl;
  cout << "total number of canvas " << numberOfCanvas << endl;

  //c->SaveAs(outdir+"/pulls_cronly"+postfix+".pdf");
  //c->SaveAs(outdir+"/pulls_cronly"+postfix+".png");
  //c->SaveAs(outdir+"/pulls_cronly"+postfix+".C");
  //c->SaveAs(outdir+"/pulls_cronly"+postfix+".root");

    for (int i =1 ; i < numberOfCanvas+1 ; i++)
        {
        int dummy = 0;
        string postfix_2= to_string(i);
        string prefix= to_string(i-1);
        int last = nuisanceRange * i;
        int start = nuisanceRange * ( i -1 );
        cout << "start  "  << start << "  last  " << last << endl;
        if (i==1) {
                h1_ref->SetAxisRange(start, last, "X");
                }
        if (i!=1 && i < numberOfCanvas) {
                h1_ref->SetAxisRange(start+1, last, "X");
                }
        if (i == numberOfCanvas){
                h1_ref->SetAxisRange(start+1, numberOfNuisance+1, "X");
                }
        c->Update();
        c->Modified();


        TString postfix_two(postfix_2.c_str()); // convert the std::string to a TString object
        TString pdfOutputFilePath = TString::Format("%s/pulls_%s_%s.pdf", outdir.Data(), postfix.Data(), postfix_two.Data());
        c->SaveAs(pdfOutputFilePath.Data());

        TString pngOutputFilePath = TString::Format("%s/pulls_%s_%s.png", outdir.Data(), postfix.Data(), postfix_two.Data());
        c->SaveAs(pngOutputFilePath.Data());

        TString cOutputFilePath = TString::Format("%s/pulls_%s_%s.C", outdir.Data(), postfix.Data(), postfix_two.Data());
        c->SaveAs(cOutputFilePath.Data());

        TString rootOutputFilePath = TString::Format("%s/pulls_%s_%s.root", outdir.Data(), postfix.Data(), postfix_two.Data());
        c->SaveAs(rootOutputFilePath.Data());

        TFile *file = TFile::Open("file_h1_ref.root","RECREATE");
        file->WriteObject(h1_ref,"h1_ref");
        file->Close();

  }


}
